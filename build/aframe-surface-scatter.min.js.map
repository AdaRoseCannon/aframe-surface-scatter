{"version":3,"file":"aframe-surface-scatter.min.js","sources":["../node_modules/three/examples/jsm/math/MeshSurfaceSampler.js","../src/aframe-surface-scatter.js"],"sourcesContent":["import {\n\tTriangle,\n\tVector3\n} from 'three';\n\n/**\n * Utility class for sampling weighted random points on the surface of a mesh.\n *\n * Building the sampler is a one-time O(n) operation. Once built, any number of\n * random samples may be selected in O(logn) time. Memory usage is O(n).\n *\n * References:\n * - http://www.joesfer.com/?p=84\n * - https://stackoverflow.com/a/4322940/1314762\n */\n\nconst _face = new Triangle();\nconst _color = new Vector3();\n\nclass MeshSurfaceSampler {\n\n\tconstructor( mesh ) {\n\n\t\tlet geometry = mesh.geometry;\n\n\t\tif ( ! geometry.isBufferGeometry || geometry.attributes.position.itemSize !== 3 ) {\n\n\t\t\tthrow new Error( 'THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh.' );\n\n\t\t}\n\n\t\tif ( geometry.index ) {\n\n\t\t\tconsole.warn( 'THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.' );\n\n\t\t\tgeometry = geometry.toNonIndexed();\n\n\t\t}\n\n\t\tthis.geometry = geometry;\n\t\tthis.randomFunction = Math.random;\n\n\t\tthis.positionAttribute = this.geometry.getAttribute( 'position' );\n\t\tthis.colorAttribute = this.geometry.getAttribute( 'color' );\n\t\tthis.weightAttribute = null;\n\n\t\tthis.distribution = null;\n\n\t}\n\n\tsetWeightAttribute( name ) {\n\n\t\tthis.weightAttribute = name ? this.geometry.getAttribute( name ) : null;\n\n\t\treturn this;\n\n\t}\n\n\tbuild() {\n\n\t\tconst positionAttribute = this.positionAttribute;\n\t\tconst weightAttribute = this.weightAttribute;\n\n\t\tconst faceWeights = new Float32Array( positionAttribute.count / 3 );\n\n\t\t// Accumulate weights for each mesh face.\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\tlet faceWeight = 1;\n\n\t\t\tif ( weightAttribute ) {\n\n\t\t\t\tfaceWeight = weightAttribute.getX( i )\n\t\t\t\t\t+ weightAttribute.getX( i + 1 )\n\t\t\t\t\t+ weightAttribute.getX( i + 2 );\n\n\t\t\t}\n\n\t\t\t_face.a.fromBufferAttribute( positionAttribute, i );\n\t\t\t_face.b.fromBufferAttribute( positionAttribute, i + 1 );\n\t\t\t_face.c.fromBufferAttribute( positionAttribute, i + 2 );\n\t\t\tfaceWeight *= _face.getArea();\n\n\t\t\tfaceWeights[ i / 3 ] = faceWeight;\n\n\t\t}\n\n\t\t// Store cumulative total face weights in an array, where weight index\n\t\t// corresponds to face index.\n\n\t\tthis.distribution = new Float32Array( positionAttribute.count / 3 );\n\n\t\tlet cumulativeTotal = 0;\n\n\t\tfor ( let i = 0; i < faceWeights.length; i ++ ) {\n\n\t\t\tcumulativeTotal += faceWeights[ i ];\n\n\t\t\tthis.distribution[ i ] = cumulativeTotal;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetRandomGenerator( randomFunction ) {\n\n\t\tthis.randomFunction = randomFunction;\n\t\treturn this;\n\n\t}\n\n\tsample( targetPosition, targetNormal, targetColor ) {\n\n\t\tconst cumulativeTotal = this.distribution[ this.distribution.length - 1 ];\n\n\t\tconst faceIndex = this.binarySearch( this.randomFunction() * cumulativeTotal );\n\n\t\treturn this.sampleFace( faceIndex, targetPosition, targetNormal, targetColor );\n\n\t}\n\n\tbinarySearch( x ) {\n\n\t\tconst dist = this.distribution;\n\t\tlet start = 0;\n\t\tlet end = dist.length - 1;\n\n\t\tlet index = - 1;\n\n\t\twhile ( start <= end ) {\n\n\t\t\tconst mid = Math.ceil( ( start + end ) / 2 );\n\n\t\t\tif ( mid === 0 || dist[ mid - 1 ] <= x && dist[ mid ] > x ) {\n\n\t\t\t\tindex = mid;\n\n\t\t\t\tbreak;\n\n\t\t\t} else if ( x < dist[ mid ] ) {\n\n\t\t\t\tend = mid - 1;\n\n\t\t\t} else {\n\n\t\t\t\tstart = mid + 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn index;\n\n\t}\n\n\tsampleFace( faceIndex, targetPosition, targetNormal, targetColor ) {\n\n\t\tlet u = this.randomFunction();\n\t\tlet v = this.randomFunction();\n\n\t\tif ( u + v > 1 ) {\n\n\t\t\tu = 1 - u;\n\t\t\tv = 1 - v;\n\n\t\t}\n\n\t\t_face.a.fromBufferAttribute( this.positionAttribute, faceIndex * 3 );\n\t\t_face.b.fromBufferAttribute( this.positionAttribute, faceIndex * 3 + 1 );\n\t\t_face.c.fromBufferAttribute( this.positionAttribute, faceIndex * 3 + 2 );\n\n\t\ttargetPosition\n\t\t\t.set( 0, 0, 0 )\n\t\t\t.addScaledVector( _face.a, u )\n\t\t\t.addScaledVector( _face.b, v )\n\t\t\t.addScaledVector( _face.c, 1 - ( u + v ) );\n\n\t\tif ( targetNormal !== undefined ) {\n\n\t\t\t_face.getNormal( targetNormal );\n\n\t\t}\n\n\t\tif ( targetColor !== undefined && this.colorAttribute !== undefined ) {\n\n\t\t\t_face.a.fromBufferAttribute( this.colorAttribute, faceIndex * 3 );\n\t\t\t_face.b.fromBufferAttribute( this.colorAttribute, faceIndex * 3 + 1 );\n\t\t\t_face.c.fromBufferAttribute( this.colorAttribute, faceIndex * 3 + 2 );\n\n\t\t\t_color\n\t\t\t\t.set( 0, 0, 0 )\n\t\t\t\t.addScaledVector( _face.a, u )\n\t\t\t\t.addScaledVector( _face.b, v )\n\t\t\t\t.addScaledVector( _face.c, 1 - ( u + v ) );\n\n\t\t\ttargetColor.r = _color.x;\n\t\t\ttargetColor.g = _color.y;\n\t\t\ttargetColor.b = _color.z;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport { MeshSurfaceSampler };\n","/* jshint esversion: 9 */\n/* For dealing with covering one object in another curves */\n/* global THREE, AFRAME */\n\nimport { MeshSurfaceSampler } from 'three/examples/jsm/math/MeshSurfaceSampler.js';\n\nconst schema = {\n\tobject: {\n\t\ttype: 'selector'\n\t},\n\tcount: {\n\t\tdefault: 128\n\t},\n\tweightAttribute: {\n\t\tdefault: ''\n\t},\n\tscale: {\n\t\ttype: 'vec3',\n\t\tdefault: new THREE.Vector3(1,1,1)\n\t},\n\trotation: {\n\t\ttype: 'vec3',\n\t\tdefault: new THREE.Vector3(0,0,0)\n\t},\n\tscaleJitter: {\n\t\ttype: 'vec3',\n\t\tdefault: new THREE.Vector3()\n\t},\n\trotationJitter: {\n\t\ttype: 'vec3',\n\t\tdefault: new THREE.Vector3()\n\t},\n\tuniformJitter: {\n\t\tdefault: true\n\t}\n};\n\ndocumentation:\n(function () {\n\tschema.object.description = `Object to place on the surface of this object`;\n\tschema.count.description = `Amount of objects`\n\tschema.weightAttribute.description = `Specifies a vertex attribute to be used as a weight when sampling from the surface. Faces with higher weights are more likely to be sampled, and those with weights of zero will not be sampled at all. For vector attributes, only .x is used in sampling. If no weight attribute is selected, sampling is randomly distributed by area.`;\n\tschema.scale.description = `Amount to scale the objects by`;\n\tschema.rotation.description = `Amount to rotate the objects by`;\n\tschema.scaleJitter.description = `Add randomness to the scaling`;\n\tschema.rotationJitter.description = `Add randomness to the rotation`;\n\tschema.uniformJitter.description = `Scale x,y,z together (true) or each independently (false)`;\n}());\n\nconst _position = new THREE.Vector3();\nconst up = new THREE.Vector3(0,1,0);\nconst _quaternion = new THREE.Quaternion();\nconst _quaternion2 = new THREE.Quaternion();\nconst _Euler = new THREE.Euler();\nconst _tempVector3 = new THREE.Vector3();\nconst _normal = new THREE.Vector3();\nconst _scale = new THREE.Vector3(1,1,1);\nconst _matrix = new THREE.Matrix4();\nAFRAME.registerComponent('surface-scatter', {\n\tschema,\n\tmultiple: true,\n\tdescription: `This component uses instancing to cover one object in another.`,\n\tinit() {\n\t\tthis.instance = [];\n\t\tthis.update = this.update.bind(this);\n\t\tthis.buildSampler = this.buildSampler.bind(this);\n\t\tthis.el.addEventListener('object3dset', this.buildSampler);\n\t\tthis.buildSampler();\n\t},\n\tbuildSampler() {\n\t\tconst geometries = [];\n\t\tthis.el.object3D.traverse(function (object) {\n\t\t\tif (!object.isInstancedMesh && object.geometry) {\n\t\t\t\tgeometries.push(object.geometry);\n\t\t\t}\n\t\t});\n\t\tif (!geometries.length) return;\n\n\t\tthis.sampler = new MeshSurfaceSampler({\n\t\t\tgeometry: THREE.BufferGeometryUtils.mergeBufferGeometries(geometries)\n\t\t});\n\t\tif (this.data.weightAttribute) {\n\t\t\tthis.sampler.setWeightAttribute( this.data.weightAttribute );\n\t\t}\n\t\tthis.sampler.build();\n\t\tthis.resample();\n\t},\n\tresample() {\n\t\tif (!this.sampler || !this.scales) return;\n\n\t\t// Sample randomly from the surface, creating an instance of the sample\n\t\t// geometry at each sample point.\n\t\tfor ( let i = 0; i < this.data.count; i ++ ) {\n\n\t\t\tthis.sampler.sample( _position, _normal );\n\t\t\t_quaternion.setFromUnitVectors(up, _normal);\n\t\t\t_tempVector3.fromArray(this.rotations[i]);\n\t\t\t_Euler.setFromVector3(_tempVector3);\n\t\t\t_quaternion2.setFromEuler(_Euler);\n\t\t\t_quaternion.multiply(_quaternion2);\n\t\t\t_scale.fromArray(this.scales[i]);\n\t\t\t_matrix.compose(_position, _quaternion, _scale);\n\t\t\tfor (const ins of this.instance) {\n\t\t\t\tins.setMatrixAt( i, _matrix );\n\t\t\t}\n\t\t}\n\n\t\tfor (const ins of this.instance) {\n\t\t\tins.instanceMatrix.needsUpdate = true;\n\t\t}\n\t},\n\tupdate(oldDetails) {\n\t\tconst data = this.data;\n\t\tconst instances = this.instance;\n\n\t\tthis.scales = [];\n\t\tfor (let i=0;i<this.data.count;i++) {\n\t\t\tconst uniformRandom = Math.random();\n\t\t\tthis.scales[i] = [\n\t\t\t\tthis.data.scale.x + (this.data.uniformJitter ? uniformRandom : Math.random()) * this.data.scaleJitter.x,\n\t\t\t\tthis.data.scale.y + (this.data.uniformJitter ? uniformRandom : Math.random()) * this.data.scaleJitter.y,\n\t\t\t\tthis.data.scale.z + (this.data.uniformJitter ? uniformRandom : Math.random()) * this.data.scaleJitter.z,\n\t\t\t];\n\t\t}\n\n\t\tthis.rotations = [];\n\t\tfor (let i=0;i<this.data.count;i++) {\n\t\t\tconst uniformRandom = Math.random();\n\t\t\tthis.rotations[i] = [\n\t\t\t\tthis.data.rotation.x + (this.data.uniformJitter ? uniformRandom : Math.random()) * this.data.rotationJitter.x * THREE.MathUtils.DEG2RAD,\n\t\t\t\tthis.data.rotation.y + (this.data.uniformJitter ? uniformRandom : Math.random()) * this.data.rotationJitter.y * THREE.MathUtils.DEG2RAD,\n\t\t\t\tthis.data.rotation.z + (this.data.uniformJitter ? uniformRandom : Math.random()) * this.data.rotationJitter.z * THREE.MathUtils.DEG2RAD,\n\t\t\t];\n\t\t}\n\n\t\tif (oldDetails.object) oldDetails.object.removeEventListener('object3dset', this.update);\n\t\tdata.object.addEventListener('object3dset', this.update);\n\n\t\tconst group = new THREE.Group();\n\t\tif (this.el.getObject3D('instances_' + (this.id || ''))) {\n\t\t\tthis.el.removeObject3D('instances_' + (this.id || ''));\n\t\t}\n\t\tinstances.splice(0);\n\t\tif (data.object) {\n\t\t\tdata.object.object3D.traverse(function (object) {\n\t\t\t\tif (object.geometry && object.material) {\n\t\t\t\t\tconst instance = new THREE.InstancedMesh(object.geometry, object.material, data.count);\n\t\t\t\t\tinstances.push(instance);\n\t\t\t\t\tgroup.add(instance);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tthis.el.setObject3D('instances_' + (this.id || ''), group);\n\t\tthis.resample();\n\t},\n\tremove() {\n\t\tthis.el.removeObject3D('instances_' + (this.id || ''));\n\t\tthis.el.removeEventListener('object3dset', this.resample);\n\t\tthis.data.object.removeEventListener('object3dset', this.update);\n\t}\n});\n"],"names":["_face","Triangle","_color","Vector3","MeshSurfaceSampler","constructor","mesh","geometry","isBufferGeometry","attributes","position","itemSize","Error","index","toNonIndexed","this","randomFunction","Math","random","positionAttribute","getAttribute","colorAttribute","weightAttribute","distribution","setWeightAttribute","name","build","faceWeights","Float32Array","count","i","faceWeight","getX","a","fromBufferAttribute","b","c","getArea","cumulativeTotal","length","setRandomGenerator","sample","targetPosition","targetNormal","targetColor","faceIndex","binarySearch","sampleFace","x","dist","start","end","mid","ceil","u","v","set","addScaledVector","undefined","getNormal","r","g","y","z","schema","object","type","default","scale","THREE","rotation","scaleJitter","rotationJitter","uniformJitter","_position","up","_quaternion","Quaternion","_quaternion2","_Euler","Euler","_tempVector3","_normal","_scale","_matrix","Matrix4","AFRAME","registerComponent","multiple","description","init","instance","update","bind","buildSampler","el","addEventListener","geometries","object3D","traverse","isInstancedMesh","push","sampler","BufferGeometryUtils","mergeBufferGeometries","data","resample","scales","setFromUnitVectors","fromArray","rotations","setFromVector3","setFromEuler","multiply","compose","ins","setMatrixAt","instanceMatrix","needsUpdate","oldDetails","instances","uniformRandom","MathUtils","DEG2RAD","removeEventListener","group","Group","getObject3D","id","removeObject3D","splice","material","InstancedMesh","add","setObject3D","remove"],"mappings":"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"}